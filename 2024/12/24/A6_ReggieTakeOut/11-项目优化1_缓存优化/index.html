<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>11-项目优化1_缓存优化 | OneTion的芝士库</title><meta name="author" content="Tion One"><meta name="copyright" content="Tion One"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="瑞吉外卖项目优化-Day01课程内容 环境搭建 缓存短信验证码 缓存菜品信息 SpringCache 缓存套餐数据  前言 1). 当前系统存在的问题  之前我们已经实现了移动端菜品展示、点餐、购物车、下单等功能，但是由于移动端是面向所有的消费者的，请求压力相对比较大，而我们当前所有的数据查询都是从数据库MySQL中直接查询的，那么可能就存在如下问题： &#x3D;&#x3D;频繁访问数据库，数据">
<meta property="og:type" content="article">
<meta property="og:title" content="11-项目优化1_缓存优化">
<meta property="og:url" content="https://onetioner.github.io/2024/12/24/A6_ReggieTakeOut/11-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%961_%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="OneTion的芝士库">
<meta property="og:description" content="瑞吉外卖项目优化-Day01课程内容 环境搭建 缓存短信验证码 缓存菜品信息 SpringCache 缓存套餐数据  前言 1). 当前系统存在的问题  之前我们已经实现了移动端菜品展示、点餐、购物车、下单等功能，但是由于移动端是面向所有的消费者的，请求压力相对比较大，而我们当前所有的数据查询都是从数据库MySQL中直接查询的，那么可能就存在如下问题： &#x3D;&#x3D;频繁访问数据库，数据">
<meta property="og:locale">
<meta property="og:image" content="https://onetioner.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-12-24T03:40:17.545Z">
<meta property="article:modified_time" content="2024-12-24T11:30:43.857Z">
<meta property="article:author" content="Tion One">
<meta property="article:tag" content="ReggieTakeOut">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://onetioner.github.io/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://onetioner.github.io/2024/12/24/A6_ReggieTakeOut/11-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%961_%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '11-项目优化1_缓存优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">OneTion的芝士库</span></a><a class="nav-page-title" href="/"><span class="site-name">11-项目优化1_缓存优化</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">11-项目优化1_缓存优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-24T03:40:17.545Z" title="Created 2024-12-24 11:40:17">2024-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-24T11:30:43.857Z" title="Updated 2024-12-24 19:30:43">2024-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ReggieTakeOut/">ReggieTakeOut</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="瑞吉外卖项目优化-Day01"><a href="#瑞吉外卖项目优化-Day01" class="headerlink" title="瑞吉外卖项目优化-Day01"></a>瑞吉外卖项目优化-Day01</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ul>
<li>环境搭建</li>
<li>缓存短信验证码</li>
<li>缓存菜品信息</li>
<li>SpringCache</li>
<li>缓存套餐数据</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>1). 当前系统存在的问题</p>
</blockquote>
<p>之前我们已经实现了移动端菜品展示、点餐、购物车、下单等功能，但是由于移动端是面向所有的消费者的，请求压力相对比较大，而我们当前所有的数据查询都是从数据库MySQL中直接查询的，那么可能就存在如下问题： &#x3D;&#x3D;频繁访问数据库，数据库访问压力大，系统性能下降，用户体验较差。&#x3D;&#x3D;</p>
<p><img src="/.io//image-20210819232120838.png" alt="image-20210819232120838"></p>
<blockquote>
<p>2). 解决该问题的方法</p>
</blockquote>
<p>要解决我们上述提到的问题，就可以使用我们前面学习的一个技术：Redis，通过Redis来做缓存，从而降低数据库的访问压力，提高系统的访问性能，从而提升用户体验。加入Redis做缓存之后，我们在进行数据查询时，就需要先查询缓存，如果缓存中有数据，直接返回，如果缓存中没有数据，则需要查询数据库，再将数据库查询的结果，缓存在redis中。</p>
<p>在环境搭建之前已经在本地建了一个git仓库和远程仓库，并推送了两个分支，不懂再看视频吧</p>
<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p><strong>1). 在项目的pom.xml文件中导入spring data redis的maven坐标</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>2). 在项目的application.yml中加入redis相关配置</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#password: root@123456</span></span><br></pre></td></tr></table></figure>



<p><strong>3). 编写Redis的配置类RedisConfig,定义RedisTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reggie.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释说明:</strong> </p>
<p>1). 在SpringBoot工程启动时, 会加载一个自动配置类 RedisAutoConfiguration, 在里面已经声明了RedisTemplate这个bean</p>
<img src="/.io//image-20210821091441695.png" alt="image-20210821091441695" style="zoom:80%;">

 

<p>上述框架默认声明的RedisTemplate用的key和value的序列化方式是默认的 JdkSerializationRedisSerializer，如果key采用这种方式序列化，最终我们在测试时通过redis的图形化界面查询不是很方便，如下形式：</p>
<p><img src="/.io//image-20210822003112692.png" alt="image-20210822003112692"></p>
<p>2). 如果使用我们自定义的RedisTemplate, key的序列化方式使用的是StringRedisSerializer, 也就是字符串形式, 最终效果如下: </p>
<p><img src="/.io//image-20210822003408377.png" alt="image-20210822003408377"></p>
<p>3). 定义了两个bean会不会出现冲突呢? 答案是不会, 因为源码如下:</p>
<img src="/.io//image-20210821092401172.png" alt="image-20210821092401172" style="zoom:80%;">

<h2 id="2-缓存短信验证码"><a href="#2-缓存短信验证码" class="headerlink" title="2. 缓存短信验证码"></a>2. 缓存短信验证码</h2><h3 id="2-1-思路分析"><a href="#2-1-思路分析" class="headerlink" title="2.1 思路分析"></a>2.1 思路分析</h3><p>前面我们已经实现了移动端手机验证码登录，随机生成的验证码我们是保存在HttpSession中的。但是在我们实际的业务场景中，一般验证码都是需要设置过期时间的，如果存在HttpSession中就无法设置过期时间，此时我们就需要对这一块的功能进行优化。</p>
<p>现在需要改造为将验证码缓存在Redis中，具体的实现思路如下：</p>
<p>1). 在服务端UserController中注入RedisTemplate对象，用于操作Redis;</p>
<p>2). 在服务端UserController的sendMsg方法中，将随机生成的验证码缓存到Redis中，并设置有效期为5分钟;</p>
<p>3). 在服务端UserController的login方法中，从Redis中获取缓存的验证码，如果登录成功则删除Redis中的验证码;</p>
<h3 id="2-2-代码改造"><a href="#2-2-代码改造" class="headerlink" title="2.2 代码改造"></a>2.2 代码改造</h3><p>1). 在UserController中注入RedisTemplate对象，用于操作Redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure>



<p>2). 在UserController的sendMsg方法中，将生成的验证码保存到Redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要将生成的验证码保存到Redis,设置过期时间</span></span><br><span class="line">redisTemplate.opsForValue().set(phone, code, <span class="number">5</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<img src="/.io//image-20210821194944557.png" alt="image-20210821194944557">

 



<p>3). 在UserController的login方法中，从Redis中获取生成的验证码，如果登录成功则删除Redis中缓存的验证码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Redis中获取缓存的验证码</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">codeInSession</span> <span class="operator">=</span> redisTemplate.opsForValue().get(phone);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从Redis中删除缓存的验证码</span></span><br><span class="line">redisTemplate.delete(phone);</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20210821195329342.png" alt="image-20210821195329342"></p>
<h3 id="2-3-功能测试"><a href="#2-3-功能测试" class="headerlink" title="2.3 功能测试"></a>2.3 功能测试</h3><p>代码编写完毕之后,重启服务。</p>
<p><strong>1). 访问前端工程，获取验证码</strong></p>
<p><img src="/.io//image-20210821200212767.png" alt="image-20210821200212767"></p>
<p>通过控制台的日志，我们可以看到生成的验证码：</p>
<p><img src="/.io//image-20210822002439892.png" alt="image-20210822002439892">  </p>
<p><strong>2). 通过Redis的图形化界面工具查看Redis中的数据</strong></p>
<img src="/.io//image-20210822003550941.png" alt="image-20210822003550941" style="zoom:97%;">

 



<p><strong>3). 在登录界面填写验证码登录完成后,查看Redis中的数据是否删除</strong></p>
<p><img src="/.io//image-20210822003732542.png" alt="image-20210822003732542"></p>
<h2 id="3-缓存菜品信息"><a href="#3-缓存菜品信息" class="headerlink" title="3. 缓存菜品信息"></a>3. 缓存菜品信息</h2><h3 id="3-1-实现思路"><a href="#3-1-实现思路" class="headerlink" title="3.1 实现思路"></a>3.1 实现思路</h3><p>前面我们已经实现了移动端菜品查看功能，对应的服务端方法为DishController的list方法，此方法会根据前端提交的查询条件(categoryId)进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p>
<p>那么,我们又需要思考一个问题, 具体缓存几份数据呢, 所有的菜品缓存一份 , 还是说需要缓存多份呢? 我们可以看一下我们之前做的移动端效果: </p>
<img src="/.io//image-20210822010136819.png" alt="image-20210822010136819" style="zoom:80%;">

 

<p>我们点击哪一个分类,展示的就是该分类下的菜品, 其他菜品无需展示。所以，这里面我们在缓存时，可以根据菜品的分类，缓存多份数据，页面在查询时，点击的是哪个分类，我们就查询该分类下的菜品缓存数据。</p>
<p><strong>具体的实现思路如下：</strong></p>
<p>1). 改造DishController的list方法，先从Redis中获取分类对应的菜品数据，如果有则直接返回，无需查询数据库;如果没有则查询数据库，并将查询到的菜品数据存入Redis。</p>
<p>2). 改造DishController的save和update方法，加入清理缓存的逻辑。</p>
<blockquote>
<p>注意： </p>
<p>​	在使用缓存过程中，要注意保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据。否则就会造成缓存数据与数据库数据不一致的情况。</p>
</blockquote>
<h3 id="3-2-代码改造"><a href="#3-2-代码改造" class="headerlink" title="3.2 代码改造"></a>3.2 代码改造</h3><p>需要改造的代码为： DishController</p>
<h4 id="3-2-1-查询菜品缓存"><a href="#3-2-1-查询菜品缓存" class="headerlink" title="3.2.1 查询菜品缓存"></a>3.2.1 查询菜品缓存</h4><table>
<thead>
<tr>
<th>改造的方法</th>
<th>redis的数据类型</th>
<th>redis缓存的key</th>
<th>redis缓存的value</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>string</td>
<td>dish_分类Id_状态 , 比如: dish_12323232323_1</td>
<td>List<DishDto></DishDto></td>
</tr>
</tbody></table>
<p><strong>1). 在DishController中注入RedisTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure>



<p><strong>2). 在list方法中,查询数据库之前,先查询缓存, 缓存中有数据, 直接返回</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态构造key</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dish.getCategoryId();</span><br><span class="line"><span class="comment">//先从redis中获取缓存数据</span></span><br><span class="line">List&lt;DishDto&gt; dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span> (dishDtoList != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果存在，直接返回，无需查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> R.success(dishDtoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20220306085148898.png" alt="image-20220306085148898"></p>
<p><strong>3). 如果redis不存在，查询数据库，并将数据库查询结果，缓存在redis，并设置过期时间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不存在，需要查询数据库，将查询到的菜品数据缓存到Redis</span></span><br><span class="line">redisTemplate.opsForValue().set(key,dishDtoList,<span class="number">60</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20220306085340938.png" alt="image-20220306085340938"></p>
<h4 id="3-2-2-清理菜品缓存"><a href="#3-2-2-清理菜品缓存" class="headerlink" title="3.2.2 清理菜品缓存"></a>3.2.2 清理菜品缓存</h4><p>为了保证数据库中的数据和缓存中的数据一致，如果数据库中的数据发生变化，需要及时清理缓存数据。所以，我们需要在添加菜品、更新菜品时清空缓存数据。</p>
<p><strong>1). 保存菜品,清空缓存</strong></p>
<p>在保存菜品的方法save中，当菜品数据保存完毕之后，需要清空菜品的缓存。那么这里清理菜品缓存的方式存在两种：</p>
<p>A. 清理所有分类下的菜品缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;dish_*&quot;</span>); <span class="comment">//获取所有以dish_xxx开头的key</span></span><br><span class="line">redisTemplate.delete(keys); <span class="comment">//删除这些key</span></span><br></pre></td></tr></table></figure>



<p>B. 清理当前添加菜品分类下的缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理某个分类下面的菜品缓存数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId();</span><br><span class="line">redisTemplate.delete(key);</span><br></pre></td></tr></table></figure>

<p>此处, 我们推荐使用第二种清理的方式, 只清理当前菜品关联的分类下的菜品数据。</p>
<p><img src="/.io//image-20220306085622169.png" alt="image-20220306085622169"></p>
<p><strong>2). 更新菜品,清空缓存</strong></p>
<p>在更新菜品的方法update中，当菜品数据更新完毕之后，需要清空菜品的缓存。这里清理缓存的方式和上述基本一致。</p>
<p>A. 清理所有分类下的菜品缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理所有菜品的缓存数据</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;dish_*&quot;</span>); <span class="comment">//获取所有以dish_xxx开头的key</span></span><br><span class="line">redisTemplate.delete(keys); <span class="comment">//删除这些key</span></span><br></pre></td></tr></table></figure>



<p>B. 清理当前添加菜品分类下的缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理某个分类下面的菜品缓存数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + dishDto.getCategoryId();</span><br><span class="line">redisTemplate.delete(key);</span><br></pre></td></tr></table></figure>

<p><img src="/.io//image-20220306085718097.png" alt="image-20220306085718097"></p>
<p>&#x3D;&#x3D;注意: 在这里我们推荐使用第一种方式进行清理，这样逻辑更加严谨。 因为对于修改操作，用户是可以修改菜品的分类的，如果用户修改了菜品的分类，那么原来分类下将少一个菜品，新的分类下将多一个菜品，这样的话，两个分类下的菜品列表数据都发生了变化。&#x3D;&#x3D;</p>
<h3 id="3-3-功能测试"><a href="#3-3-功能测试" class="headerlink" title="3.3 功能测试"></a>3.3 功能测试</h3><p>代码编写完毕之后,重新启动服务。</p>
<p>1). 访问移动端，根据分类查询菜品列表，然后再检查Redis的缓存数据，是否可以正常缓存；</p>
<p><img src="/.io//image-20210822221038509.png" alt="image-20210822221038509"></p>
<p>我们也可以在服务端，通过debug断点的形式一步一步的跟踪代码的执行。</p>
<p>2). 当我们在进行新增及修改菜品时, 查询Redis中的缓存数据, 是否被清除;</p>
<h2 id="4-SpringCache"><a href="#4-SpringCache" class="headerlink" title="4. SpringCache"></a>4. SpringCache</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p><strong>Spring Cache</strong>是一个缓存框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能，大大简化我们在业务中操作缓存的代码。</p>
<p>Spring Cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过<strong>CacheManager</strong>接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口。</p>
<p>针对不同的缓存技术需要实现不同的CacheManager：</p>
<table>
<thead>
<tr>
<th><strong>CacheManager</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EhCacheCacheManager</td>
<td>使用EhCache作为缓存技术</td>
</tr>
<tr>
<td>GuavaCacheManager</td>
<td>使用Google的GuavaCache作为缓存技术</td>
</tr>
<tr>
<td>RedisCacheManager</td>
<td>使用Redis作为缓存技术</td>
</tr>
</tbody></table>
<h3 id="4-2-注解"><a href="#4-2-注解" class="headerlink" title="4.2 注解"></a>4.2 注解</h3><p>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@EnableCaching</td>
<td>开启缓存注解功能，一般放在启动类上</td>
</tr>
<tr>
<td>&#x3D;&#x3D;@Cacheable&#x3D;&#x3D;</td>
<td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中，一般方法上。</td>
</tr>
<tr>
<td>@CachePut</td>
<td>将方法的返回值放到缓存中，一般方法上</td>
</tr>
<tr>
<td>&#x3D;&#x3D;@CacheEvict&#x3D;&#x3D;</td>
<td>将一条或多条数据从缓存中删除</td>
</tr>
</tbody></table>
<p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p>
<p>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</p>
<h3 id="4-3-入门程序"><a href="#4-3-入门程序" class="headerlink" title="4.3 入门程序"></a>4.3 入门程序</h3><p>接下来，我们将通过一个入门案例来演示一下SpringCache的常见用法。 上面我们提到，SpringCache可以集成不同的缓存技术，如Redis、Ehcache甚至我们可以使用Map来缓存数据， 接下来我们在演示的时候，就先通过一个Map来缓存数据，最后我们再换成Redis来缓存。</p>
<h4 id="4-3-1-环境准备"><a href="#4-3-1-环境准备" class="headerlink" title="4.3.1 环境准备"></a>4.3.1 环境准备</h4><p><strong>1). 数据库准备</strong></p>
<p>将今天资料中的 &#x3D;&#x3D;cache_demo.sql&#x3D;&#x3D; SQL脚本直接导入数据库中。</p>
<p><img src="/.io//image-20210822230236957.png" alt="image-20210822230236957"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database cache_demo;</span><br><span class="line"><span class="keyword">create table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id      <span class="type">bigint</span> auto_increment</span><br><span class="line">        <span class="keyword">primary key</span>,</span><br><span class="line">    name    <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">null</span>,</span><br><span class="line">    age     <span class="type">int</span>         <span class="keyword">null</span>,</span><br><span class="line">    address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>2). 导入基础工程</strong></p>
<p>基础环境的代码，在我们今天的资料中已经准备好了， 大家只需要将这个工程导入进来就可以了。导入进来的工程结构如下： </p>
<p><img src="/.io//image-20210822225934512.png" alt="image-20210822225934512"></p>
<p>由于SpringCache的基本功能是Spring核心(spring-context)中提供的，所以目前我们进行简单的SpringCache测试，是可以不用额外引入其他依赖的。</p>
<p><strong>3). 注入CacheManager</strong></p>
<p>我们可以在UserController注入一个CacheManager，在Debug时，我们可以通过CacheManager跟踪缓存中数据的变化。</p>
<img src="/.io//image-20210822231333527.png" alt="image-20210822231333527" style="zoom:80%;">

 



<p>我们可以看到CacheManager是一个接口，默认的实现有以下几种 ；</p>
<p><img src="/.io//image-20210822231217450.png" alt="image-20210822231217450"></p>
<p>而在上述的这几个实现中，默认使用的是 ConcurrentMapCacheManager。稍后我们可以通过断点的形式跟踪缓存数据的变化。</p>
<p><strong>4). 引导类上加@EnableCaching</strong></p>
<p>在引导类上加该注解，就代表当前项目开启缓存注解功能。</p>
<p><img src="/.io//image-20210822231616569.png" alt="image-20210822231616569"></p>
<h4 id="4-3-2-Cacheable注解"><a href="#4-3-2-Cacheable注解" class="headerlink" title="4.3.2 @Cacheable注解"></a>4.3.2 @Cacheable注解</h4><blockquote>
<p>@Cacheable 说明:</p>
<p>​	作用：在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</p>
<p>​	value：缓存的名称，每个缓存名称下面可以有多个key</p>
<p>​	key：缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p>
</blockquote>
<p><strong>1). 在get方法上加注解 @Cacheable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Cacheable</span>注解：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 		userCache属性：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment"> * 		key属性：缓存的key，支持Spring的表达式语言SPEL语法</span></span><br><span class="line"><span class="comment"> * 		condition属性：条件，满足条件时才缓存数据</span></span><br><span class="line"><span class="comment"> * 		unless属性：满足条件则不缓存，与上述的condition是反向的。</span></span><br><span class="line"><span class="comment"> * 			注意：此处，我们使用的时候只能够使用 unless， 因为在condition中，我们是无法获取到结果 #result的。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * http://127.0.0.1:8080/user/get/1494154126820454401</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2). 测试</strong></p>
<p>我们可以重启服务，然后通过debug断点跟踪程序执行。我们发现，第一次访问，会请求我们controller的方法，查询数据库。后面再查询相同的id，就直接获取到数据库，不用再查询数据库了，就说明缓存生效了。</p>
<p>当我们在测试时，查询一个数据库不存在的id值，第一次查询缓存中没有，也会查询数据库。而第二次再查询时，会发现，不再查询数据库了，而是直接返回，那也就是说如果根据ID没有查询到数据,那么会自动缓存一个null值。 我们可以通过debug，验证一下： </p>
<p><img src="/.io//image-20210823002907048.png" alt="image-20210823002907048"></p>
<p>我们能不能做到，当查询到的值不为null时，再进行缓存，如果为null，则不缓存呢? 答案是可以的。</p>
<p><strong>3). 缓存非null值</strong></p>
<p>在@Cacheable注解中，提供了两个属性分别为： condition， unless 。</p>
<blockquote>
<p>condition : 表示满足什么条件, 再进行缓存 ;</p>
<p>unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ;</p>
</blockquote>
<p>具体实现方式如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;get/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;, unless = &quot;#result == null&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意： 此处，我们使用的时候只能够使用 unless， 因为在condition中，我们是无法获取到结果 #result的。&#x3D;&#x3D;</p>
<p><strong>4). 在list方法上加注解@Cacheable</strong></p>
<p>在list方法中进行查询时，有两个查询条件，如果传递了id，根据id查询； 如果传递了name， 根据name查询，那么我们缓存的key在设计的时候，就需要既包含id，又包含name。 具体的代码实现如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据条件查询用户信息</span></span><br><span class="line"><span class="comment"> * http://127.0.0.1:8080/user/list?id=1494154126820454401&amp;name=zs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;user&quot;, key = &quot;#user.id + &#x27;_&#x27; + #user.name&quot;, unless = &quot;#result.size() == 0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(user.getId() != <span class="literal">null</span>, User::getId, user.getId());</span><br><span class="line">    queryWrapper.eq(user.getName() != <span class="literal">null</span>, User::getName, user.getName());</span><br><span class="line">    <span class="keyword">return</span> userService.list(queryWrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>然后再次重启服务，进行测试。</p>
<p>第一次查询时，需要查询数据库，在后续的查询中，就直接查询了缓存，不再查询数据库了。</p>
<p>&#x3D;&#x3D;注意: 上述的演示，最终的数据，实际上是缓存在ConcurrentHashMap中，那么当我们的服务器重启之后，缓存中的数据就会丢失。 我们后面使用了Redis来缓存就不存在这样的问题了。&#x3D;&#x3D;</p>
<h4 id="4-3-3-CacheEvict注解"><a href="#4-3-3-CacheEvict注解" class="headerlink" title="4.3.3 @CacheEvict注解"></a>4.3.3 @CacheEvict注解</h4><blockquote>
<p>@CacheEvict 说明： </p>
<p>​	作用: 清理指定缓存</p>
<p>​	value: 缓存的名称，每个缓存名称下面可以有多个key</p>
<p>​	key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</p>
</blockquote>
<p><strong>1). 在 delete 方法上加注解@CacheEvict</strong></p>
<p>当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用@CacheEvict注解, 具体的使用方式如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id删除用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CacheEvict</span>：清理指定缓存 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * cacheNames属性：缓存的名称，每个缓存名称下面可以有多个key</span></span><br><span class="line"><span class="comment"> * key属性：缓存的key</span></span><br><span class="line"><span class="comment"> * allEntries属性：清楚所有的key</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * http://127.0.0.1:8080/user/delete/1494154126820454400</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;delete/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    userService.removeById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>2). 测试</strong></p>
<p>要测试缓存的删除，我们先访问save方法4次，保存4条数据到数据库的同时，也保存到缓存中，最终我们可以通过debug看到缓存中的数据信息。 然后我们访问delete方法。 </p>
<p>删除数据时，通过debug我们可以看到已经缓存的4条数据：</p>
<p><img src="/.io//image-20210823000458089.png" alt="image-20210823000458089"></p>
<p>当执行完delete操作之后，我们再次保存一条数据，在保存的时候debug查看一下删除的ID值是否已经被删除。</p>
<p><img src="/.io//image-20210823000733218.png" alt="image-20210823000733218"></p>
<p><strong>3). 在 update 方法上加注解@CacheEvict</strong></p>
<p>在更新数据之后，数据库的数据已经发生了变更，我们需要将缓存中对应的数据删除掉，避免出现数据库数据与缓存数据不一致的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id更新用户信息</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * http://127.0.0.1:8080/user/update?id=1494154126820454401&amp;name=zz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;update&quot;)</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;user&quot;, key = &quot;#user.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    userService.updateById(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>加上注解之后，我们可以重启服务，然后测试方式，基本和上述相同，先缓存数据，然后再更新某一条数据，通过debug的形式查询缓存数据的情况。</p>
<h3 id="4-4-集成-Redis"><a href="#4-4-集成-Redis" class="headerlink" title="4.4 集成 Redis"></a>4.4 集成 Redis</h3><p>在使用上述默认的ConcurrentHashMap做缓存时，服务重启之后，之前缓存的数据就全部丢失了，操作起来并不友好。在项目中使用，我们会选择使用redis来做缓存，主要需要操作以下几步： </p>
<p>1). pom.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2). application.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">120000</span>   <span class="comment">#设置缓存过期时间，可选</span></span><br></pre></td></tr></table></figure>



<p>3). 测试</p>
<p>重新启动项目，发送根据id查询数据的请求，然后通过redis的图形化界面工具，查看redis中是否可以正常的缓存数据。</p>
<p><img src="/.io//image-20210823010742530.png" alt="image-20210823010742530"></p>
<h2 id="5-缓存套餐数据"><a href="#5-缓存套餐数据" class="headerlink" title="5. 缓存套餐数据"></a>5. 缓存套餐数据</h2><h3 id="5-1-实现思路"><a href="#5-1-实现思路" class="headerlink" title="5.1 实现思路"></a>5.1 实现思路</h3><p>前面我们已经实现了移动端套餐查看功能，对应的服务端方法为SetmealController的list方法，此方法会根据前端提交的查询条件进行数据库查询操作。在高并发的情况下，频繁查询数据库会导致系统性能下降，服务端响应时间增长。现在需要对此方法进行缓存优化，提高系统的性能。</p>
<p>具体的实现思路如下：</p>
<p>1). 导入Spring Cache和Redis相关maven坐标</p>
<p>2). 在application.yml中配置缓存数据的过期时间</p>
<p>3). 在启动类上加入@EnableCaching注解，开启缓存注解功能</p>
<p>4). 在SetmealController的list方法上加入@Cacheable注解</p>
<p>5). 在SetmealController的save和delete方法上加入CacheEvict注解</p>
<h3 id="5-2-缓存套餐数据"><a href="#5-2-缓存套餐数据" class="headerlink" title="5.2 缓存套餐数据"></a>5.2 缓存套餐数据</h3><h4 id="5-2-1-代码实现"><a href="#5-2-1-代码实现" class="headerlink" title="5.2.1 代码实现"></a>5.2.1 代码实现</h4><p>1). pom.xml中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2). application.yml中设置缓存过期时间</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">120000</span> <span class="comment">#设置缓存数据的过期时间，单位：毫秒</span></span><br></pre></td></tr></table></figure>



<p>3). 启动类上加入@EnableCaching注解</p>
<p><img src="/.io//image-20210823232419408.png" alt="image-20210823232419408"></p>
<p>4). SetmealController的list方法上加入@Cacheable注解</p>
<p>在进行套餐数据查询时，我们需要根据分类ID和套餐的状态进行查询，所以我们在缓存数据时，可以将套餐分类ID作为key，如： 1627182182 (1627182182为分类ID)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据条件查询套餐数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> setmeal</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;setmealCache&quot;, key = &quot;#setmeal.categoryId&quot;, unless = &quot;#result.data.size()==0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="title function_">list</span><span class="params">(Setmeal setmeal)</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(setmeal.getCategoryId() != <span class="literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());</span><br><span class="line">    queryWrapper.eq(setmeal.getStatus() != <span class="literal">null</span>,Setmeal::getStatus,setmeal.getStatus());</span><br><span class="line">    queryWrapper.orderByDesc(Setmeal::getUpdateTime);</span><br><span class="line"></span><br><span class="line">    List&lt;Setmeal&gt; list = setmealService.list(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="5-2-2-测试"><a href="#5-2-2-测试" class="headerlink" title="5.2.2 测试"></a>5.2.2 测试</h4><p>缓存数据的代码编写完毕之后，重新启动服务，访问移动端进行测试，我们登陆之后在点餐界面，点击某一个套餐分类，查询套餐列表数据时，服务端报错了，错误信息如下： </p>
<img src="/.io//image-20210823233406888.png" alt="image-20210823233406888" style="zoom:80%;">

 

<p><img src="/.io//image-20210823233514356.png" alt="image-20210823233514356"></p>
<p>&#x3D;&#x3D;为什么会报出这个错误呢？&#x3D;&#x3D;</p>
<p>因为 @Cacheable 会将方法的返回值R缓存在Redis中，而在Redis中存储对象，该对象是需要被序列化的，而对象要想被成功的序列化，就必须得实现 Serializable 接口。而当前我们定义的R，并未实现 Serializable 接口。所以，要解决该异常，只需要让R 实现  Serializable 接口即可。如下： </p>
<p><img src="/.io//image-20210823233904520.png" alt="image-20210823233904520"></p>
<p>修复完毕之后，再次重新测试，访问套餐分类下对应的套餐列表数据后，我们会看到Redis中确实可以缓存对应的套餐列表数据。</p>
<p><img src="/.io//image-20210823234146526.png" alt="image-20210823234146526"></p>
<h3 id="5-3-清理套餐数据"><a href="#5-3-清理套餐数据" class="headerlink" title="5.3 清理套餐数据"></a>5.3 清理套餐数据</h3><h4 id="5-3-1-代码实现"><a href="#5-3-1-代码实现" class="headerlink" title="5.3.1 代码实现"></a>5.3.1 代码实现</h4><p>为了保证数据库中数据与缓存数据的一致性，在我们添加套餐或者删除套餐数据之后，需要清空当前套餐缓存的全部数据。那么@CacheEvict注解如何清除某一份缓存下所有的数据呢，这里我们可以指定@CacheEvict中的一个属性 allEnties，将其设置为true即可。</p>
<p><strong>1). 在delete方法上加注解@CacheEvict</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span> <span class="comment">//清除setmealCache名称下,所有的缓存数据</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;ids:&#123;&#125;&quot;</span>,ids);</span><br><span class="line">    setmealService.removeWithDish(ids);</span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;套餐数据删除成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2). 在delete方法上加注解@CacheEvict</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增套餐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> setmealDto</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@CacheEvict(value = &quot;setmealCache&quot;,allEntries = true)</span> <span class="comment">//清除setmealCache名称下,所有的缓存数据</span></span><br><span class="line"><span class="keyword">public</span> R&lt;String&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;套餐信息：&#123;&#125;&quot;</span>,setmealDto);</span><br><span class="line"></span><br><span class="line">    setmealService.saveWithDish(setmealDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R.success(<span class="string">&quot;新增套餐成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="5-3-2-测试"><a href="#5-3-2-测试" class="headerlink" title="5.3.2 测试"></a>5.3.2 测试</h4><p>代码编写完成之后,重启工程,然后访问后台管理系统,对套餐数据进行新增 以及 删除, 然后通过Redis的图形化界面工具,查看Redis中的套餐缓存是否已经被删除。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://onetioner.github.io">Tion One</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://onetioner.github.io/2024/12/24/A6_ReggieTakeOut/11-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%961_%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/">https://onetioner.github.io/2024/12/24/A6_ReggieTakeOut/11-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%961_%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ReggieTakeOut/">ReggieTakeOut</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/12-%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%962_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="12-项目优化2_主从复制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">12-项目优化2_主从复制</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖项目优化-Day02课程内容 MySQL主从复制 读写分离案例 项目实现读写分离 Nginx-概述 Nginx-命令 Nginx-应用  前言 1). 存在的问题  在前面基础功能实现的过程中，我们后台管理系统及移动端的用户，在进行数据访问时，都是直接操作数据库MySQL的。结构如下图：       而在当前，MySQL服务器只有一台，那么就可能会存在如下问题：  1). 读和写所有压力都由一台数据库承担，压力大 2). 数据库服务器磁盘损坏则数据丢失，单点故障  2). 解决方案  为了解决上述提到的两个问题，我们可以准备两台MySQL，一台主(Master)服务器，一台从(Slave)服务器，主库的数据变更，需要同步到从库中(主从复制)。而用户在访问我们项目时，如果是写操作(insert、update、delete)，则直接操作主库；如果是读(select)操作，则直接操作从库(在这种读写分离的结构中，从库是可以有多个的)，这种结构我们称为 读写分离 。      今天我们就需要实现上述的架构，来解决业务开发中所存在的问题。 1....</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/10-Redis%E5%9F%BA%E7%A1%80/" title="10-Redis基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">10-Redis基础</div></div><div class="info-2"><div class="info-item-1">Redis基础课程内容 Redis入门 Redis数据类型 Redis常用命令 在Java中操作Redis  1. 前言1.1 什么是RedisRedis是一个基于内存的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的存储中间件，它是「Remote Dictionary Service」的首字母缩写，也就是「远程字典服务」。   基于内存存储，读写性能高     适合存储热点数据（热点商品、资讯、新闻）     企业应用广泛   1.2 使用Redis能做什么 数据缓存 消息队列 注册中心 发布订阅  2. Redis入门2.1 Redis简介Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/01-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA_%E5%90%8E%E5%8F%B0%E7%99%BB%E5%BD%95%E9%80%80%E5%87%BA/" title="01-项目介绍_环境搭建_后台登录退出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">01-项目介绍_环境搭建_后台登录退出</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖-Day01课程内容 软件开发整体介绍  瑞吉外卖项目介绍  开发环境搭建  后台登录功能开发  后台退出功能开发   1. 软件开发整体介绍作为一名软件开发工程师,我们需要了解在软件开发过程中的开发流程， 以及软件开发过程中涉及到的岗位角色，角色的分工、职责， 并了解软件开发中涉及到的三种软件环境。那么这一小节，我们将从 软件开发流程、角色分工、软件环境 三个方面，来整体上介绍一下软件开发。 1.1 软件开发流程 1). 第1阶段: 需求分析 完成产品原型、需求规格说明书的编写。   产品原型，一般是通过网页(html)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。  需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。 2). 第2阶段: 设计 设计的内容包含...</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/02-%E5%AE%8C%E5%96%84%E7%99%BB%E5%BD%95_%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86/" title="02-完善登录_员工信息管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">02-完善登录_员工信息管理</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖-Day02课程内容 完善登录功能  新增员工  员工信息分页查询  启用&#x2F;禁用员工账号  编辑员工信息   1. 完善登录功能1.1 问题分析前面我们已经完成了后台系统的员工登录功能开发，但是目前还存在一个问题，接下来我们来说明一个这个问题， 以及如何处理。 1). 目前现状 用户如果不登录，直接访问系统首页面，照样可以正常访问。   2). 理想效果 上述这种设计并不合理，我们希望看到的效果应该 是，只有登录成功后才可以访问系统中的页面，如果没有登录, 访问系统中的任何界面都直接跳转到登录页面。        那么，具体应该怎么实现呢？ 1.2 思路分析拦截器具体的处理逻辑如下： A. 判断登录状态，如果已登录，则直接放行 B. 如果未登录, 则返回未登录结果 如果未登录,我们需要给前端返回什么样的结果呢? 这个时候, 我们可以去看看前端是如何处理的 ?      1.3 代码实现1). 定义登录校验拦截器 所属包:   com.itheima.reggie.common 123456789101112131415161718192021222324/**...</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/03-%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85_%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/" title="03-公共字段自动填充_分类管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">03-公共字段自动填充_分类管理</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖-Day03课程内容 公共字段自动填充 新增分类 分类信息分页查询 删除分类 修改分类  1. 公共字段自动填充1.1 问题分析前面我们已经完成了后台系统的员工管理功能的开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间、修改人等字段。这些字段属于公共字段，也就是也就是在我们的系统中很多表中都会有这些字段，如下：  而针对于这些字段，我们的赋值方式为：  A. 在新增数据时, 将createTime、updateTime 设置为当前时间, createUser、updateUser设置为当前登录用户ID。 B. 在更新数据时, 将updateTime 设置为当前时间, updateUser设置为当前登录用户ID。 目前,在我们的项目中处理这些字段都是在每一个业务方法中进行赋值操作,如下:             如果都按照上述的操作方式来处理这些公共字段, 需要在每一个业务方法中进行操作, 编码相对冗余、繁琐，那能不能对于这些公共字段在某个地方统一处理，来简化开发呢？ 答案是可以的，我们使用Mybatis...</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/04-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD_%E8%8F%9C%E5%93%81%E7%AE%A1%E7%90%86/" title="04-文件上传下载_菜品管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">04-文件上传下载_菜品管理</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖-Day04课程内容 文件上传下载 菜品新增 菜品分页查询 菜品修改  1. 文件上传下载1.1 上传介绍1.1.1 概述文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。        文件上传时，对页面的form表单有如下要求：    表单属性 取值 说明    method post 必须选择post方式提交   enctype multipart&#x2F;form-data 采用multipart格式上传文件   type file 使用input的file控件上传   1.1.2 前端介绍1). 简单html页面表单 1234&lt;form method=&quot;post&quot; action=&quot;/common/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input name=&quot;myFile&quot;...</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/07-Git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/" title="07-Git版本管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">07-Git版本管理</div></div><div class="info-2"><div class="info-item-1">Git 分布式版本控制工具课程内容 Git概述 Git代码托管服务 Git常用命令 在IDEA中使用Git  1. 前言1.1 什么是GitGit是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等），在软件开发过程中被广泛使用。 在IDEA开发工具中可以集成Git（后面会讲解Git安装和集成过程）：  集成后在IDEA中可以看到Git相关图标： 可以通过启动两个IDEA窗口模拟两个开发人员来展示Git的使用：  其他的版本控制工具：  SVN CVS VSS  1.2 使用Git能做什么 代码回溯：Git在管理文件过程中会记录日志，方便回退到历史版本 版本切换：Git存在分支的概念，一个项目可以有多个分支（版本），可以任意切换 多人协作：Git支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过Git就可以管理和协调 远程备份：Git通过仓库管理文件，在Git中存在远程仓库，如果本地文件丢失还可以从远程仓库获取  2. Git概述2.1 Git简介Git...</div></div></div></a><a class="pagination-related" href="/2024/12/24/A6_ReggieTakeOut/05-%E5%A5%97%E9%A4%90%E7%AE%A1%E7%90%86_%E7%9F%AD%E4%BF%A1%E5%8F%91%E9%80%81/" title="05-套餐管理_短信发送"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">05-套餐管理_短信发送</div></div><div class="info-2"><div class="info-item-1">瑞吉外卖-第五天课程内容 新增套餐  套餐分页查询  删除套餐  短信发送  手机验证码登录   1. 新增套餐1.1 需求分析套餐就是菜品的集合。 后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。        1.2 数据模型新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据。所以在新增套餐时，涉及到两个表：    表 说明 备注    setmeal 套餐表 存储套餐的基本信息   setmeal_dish 套餐菜品关系表 存储套餐关联的菜品的信息(一个套餐可以关联多个菜品)   两张表具体的表结构如下:  1). 套餐表setmeal  在该表中，套餐名称name字段是不允许重复的，在建表时，已经创建了唯一索引。   2). 套餐菜品关系表setmeal_dish  在该表中，菜品的名称name,菜品的原价price...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Tion One</div><div class="author-info-description">在芝士库中沉沦</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-Day01"><span class="toc-number">1.</span> <span class="toc-text">瑞吉外卖项目优化-Day01</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.</span> <span class="toc-text">课程内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">1. 环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.1 环境准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">2. 缓存短信验证码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">2.1 思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E6%94%B9%E9%80%A0"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.2 代码改造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">2.3 功能测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%AD%98%E8%8F%9C%E5%93%81%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.</span> <span class="toc-text">3. 缓存菜品信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">3.1 实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E6%94%B9%E9%80%A0"><span class="toc-number">1.5.2.</span> <span class="toc-text">3.2 代码改造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%9F%A5%E8%AF%A2%E8%8F%9C%E5%93%81%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">3.2.1 查询菜品缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%B8%85%E7%90%86%E8%8F%9C%E5%93%81%E7%BC%93%E5%AD%98"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">3.2.2 清理菜品缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.3 功能测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SpringCache"><span class="toc-number">1.6.</span> <span class="toc-text">4. SpringCache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">4.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.2.</span> <span class="toc-text">4.2 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">4.3 入门程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">4.3.1 环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Cacheable%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">4.3.2 @Cacheable注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-CacheEvict%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">4.3.3 @CacheEvict注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%9B%86%E6%88%90-Redis"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.4 集成 Redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E5%A5%97%E9%A4%90%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.</span> <span class="toc-text">5. 缓存套餐数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.1.</span> <span class="toc-text">5.1 实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BC%93%E5%AD%98%E5%A5%97%E9%A4%90%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.2.</span> <span class="toc-text">5.2 缓存套餐数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">5.2.1 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">5.2.2 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%B8%85%E7%90%86%E5%A5%97%E9%A4%90%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">5.3 清理套餐数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">5.3.1 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">5.3.2 测试</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/A8_Microservice/07-Elasticsearch/" title="07-Elasticsearch">07-Elasticsearch</a><time datetime="2024-12-24T03:47:29.582Z" title="Created 2024-12-24 11:47:29">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/A8_Microservice/06-Elasticsearch/" title="06-Elasticsearch">06-Elasticsearch</a><time datetime="2024-12-24T03:46:59.831Z" title="Created 2024-12-24 11:46:59">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/A8_Microservice/05-Elasticsearch/" title="05-Elasticsearch">05-Elasticsearch</a><time datetime="2024-12-24T03:46:10.237Z" title="Created 2024-12-24 11:46:10">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/A8_Microservice/04-RabbitMQ/" title="04-RabbitMQ">04-RabbitMQ</a><time datetime="2024-12-24T03:45:43.647Z" title="Created 2024-12-24 11:45:43">2024-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/A8_Microservice/03-Docker/" title="03-Docker">03-Docker</a><time datetime="2024-12-24T03:45:20.250Z" title="Created 2024-12-24 11:45:20">2024-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Tion One</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>